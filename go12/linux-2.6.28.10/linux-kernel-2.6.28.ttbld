get_kernel_revision() {
        if ! p4out=$(p4 where ... 2>&1); then
                die "You need to set your P4CLIENT environment variable"
        fi
        if ! p4out=$(p4 opened -m 1 ... 2>&1); then
                die "Perforce command 'p4 opened' failed: ${p4out}"
        fi
        if ! echo "${p4out}" \
                | grep -Fq "... - file(s) not opened on this client.";
        then
                dirty="y"
        else
                dirty="n"
        fi
        if ! p4out=$(p4 changes -m 1 -s submitted ../initramfs/...#have ...#have);
        then
                die "Perforce command 'p4 changes' failed: ${p4out}"
        fi
        X_COMPONENT_P4_CHANGELIST=$(echo "${p4out}" | awk ' \
		BEGIN \
		{
			latest=0;
		}
		{
			current=strtonum( $2 );
			if( latest < current )
				latest=current;
		}
		END \
		{
			if( latest != 0 )
				printf( "%lu\n", latest );
		}')
        if test "${dirty}" = "y";
        then
                X_COMPONENT_P4_CHANGELIST="${X_COMPONENT_P4_CHANGELIST}-$(whoami)"
        fi
        export X_COMPONENT_P4_CHANGELIST
}

# linux-kernel-xxx.ttbld
if [ "${XOPT_KERNEL_WORKSPACE}" != "" ]; then
	export P4CLIENT="${XOPT_KERNEL_WORKSPACE}"
fi

get_kernel_revision
VERSION="$(make --no-print-directory -s kernelversion)-tt${X_COMPONENT_P4_CHANGELIST}"

# Which configuration should we use?
# TODO The mapping should have been much simpler if
# the configuration file would have been named:
#   "${X_ARCH}${XOPT_OPROFILE_SUFFIX}${XOPT_CAPTS_SUFFIX}_defconfig"
# such as:
#   seoul2_defconfig
#   seoul2-oprofile_defconfig
#   torinos_defconfig
#   torinos-capts_defconfig
#   torinos-oprofile-capts_defconfig
# etc...
get_kernel_config() {
	local ext=""
	[ "${IOPT_FLASHER}" = "y" ] && ext="_flasher"
	[ "${XOPT_NAV2}" = "y" ] && ext="_nav2"
	echo "${X_ARCH}${ext}_defconfig"
}

do_build() {
	# Modules required to support factory tools
	factory_modules="userspace-consumer mem"

	export ARCH="arm"
	export CROSS_COMPILE="${X_CROSS_TOOLCHAIN_PREFIX}-" 
	export PATH=${X_NATIVE_STAGING}/bin:${PATH}

	if [ "${XOPT_VERBOSE}" = "y" ]; then
		makeflags="-w V=1"
	else
		makeflags="-ws V=0"
	fi
	defcfg="./arch/arm/configs/"$(get_kernel_config)
	if [ ! -f ${defcfg} ]; then
		echo "${defcfg} does not exist!" >&2
		return 1
	fi
	# Copy initramfs cpio from staging to local directory
	# This allow us to build from whatever the current staging is.
	cp ${X_STAGING}/usr/initramfs.cpio.gz . \
		|| die "Unable to copy initramfs.cpio.gz from staging"
	# TODO For compatibility with prebuild kernel .ko modules (halaudio.ko)
	# We should not append -ttXXXXXX at the version.
	# echo "-tt${X_COMPONENT_P4_CHANGELIST}" > localversion
	echo "" > localversion
	if ! cat > tomtom.ver << __EOT__
# This file generated by $0, DO NOT EDIT

TTVER=${X_COMPONENT_P4_CHANGELIST}

# EOF
__EOT__
	then
		echo "Unable to write version file tomtom.ver" >&2
		return 1
	fi

	chmod -c --quiet 644 .config 

	# no point in building two kernels for the oprofile .ipk
	if [ "${XOPT_OPROFILE}" != "y" ]
	then
		echo "Configuring DEBUG kernel with ${defcfg}..."
		echo "CONFIG_TOMTOM_VERSION=$X_COMPONENT_P4_CHANGELIST" > .config

		# change some options for the debug kernel
		(
			perl -ne \
				's/CONFIG_(MODULE_HASHES)=y/# CONFIG_$1 is not set/;	\
				s/# CONFIG_(MAGIC_SYSRQ|TOMTOM_DEBUG_KERNEL) is not set/CONFIG_$1=y/; \
				print' ${defcfg} 
			#echo '# CONFIG_KALLSYMS_ALL is not set'
			#echo '# CONFIG_KALLSYMS_EXTRA_PASS is not set'

		) >> .config

		make ${makeflags} silentoldconfig || return 1
		make ${makeflags} ${XOPT_MAKE_JOBS} zImage || return 1
		mv arch/arm/boot/zImage arch/arm/boot/zImage.debug
		rm -f vmlinux
	fi

	echo "Configuring NORMAL kernel with ${defcfg}..."
	echo "CONFIG_TOMTOM_VERSION=$X_COMPONENT_P4_CHANGELIST" > .config
	cat "${defcfg}" >> .config

	if [ "${XOPT_OPROFILE}" = "y" ]
	then
		# add some extra options needed for oprofile
		echo "CONFIG_OPROFILE=y" >> .config
		echo "CONFIG_OPROFILE_ARMV6=y" >> .config
		echo "CONFIG_OPROFILE_ARM11_CORE=y" >> .config
		echo "CONFIG_PROFILING=y" >> .config
	fi

	[ "${XOPT_MMC_TRANSFER_LOGGING}" = "y" ] && echo "CONFIG_MMC_TRANSFER_LOGGING=y" >> .config
	if [ "${XOPT_GZIP_KERNEL_DECOMPRESSION}" = "y" ]; then
		echo "CONFIG_KERNEL_GZIP=y" >> .config
		echo "CONFIG_KERNEL_LZO=n" >> .config
	fi

	make ${makeflags} silentoldconfig || return 1

	if [ "${XOPT_DEBUG}" = "y" ]; then
		strip_modules=""
	else
		strip_modules="INSTALL_MOD_STRIP=1"
	fi
	rm -Rf modinst


	if [ "${IOPT_FLASHER}" != "y" ]
	then
		make ${makeflags} ${XOPT_MAKE_JOBS} modules || return 1
	fi

	# pull in the sha1 hashes of out-of-tree modules
	rm -f *.ko.sha1
	find ${X_STAGING}/lib/modules -name \*.ko.sha1 \! -exec ln -sf {} \;

	if [ "${XOPT_RELEASE}" = "y" ]; then
		make ${makeflags} ${XOPT_MAKE_JOBS} zImage RELEASE=1 || return 1
		mv arch/arm/boot/zImage arch/arm/boot/zImage.retail

		# production kernels are not signed by the kernel build script
		for KEY in $(ls -r ../production_keys/tt_kernel_prod_privkey_?.dsa.gpg)
		do
			gpg -d $KEY | scripts/sign_image -k - arch/arm/boot/zImage.retail
		done		
	fi

	make ${makeflags} ${XOPT_MAKE_JOBS} zImage || return 1

	KVER=$(cat include/config/kernel.release)
	mkdir -p ${X_STAGING}/lib/modules/${KVER}
	if [ "${IOPT_FLASHER}" != "y" ]
	then
		make ${makeflags} ${XOPT_MAKE_JOBS} \
			${strip_modules} INSTALL_MOD_PATH=modinst \
			modules_install || return 1
	fi

	# Remove symlinks to original source tree, does not make sense
	# on the PND...
	find modinst/ \( -name build -or -name source \) -and -type l \
		-exec rm {} \;

	# pull in the out-of-tree modules for depmod if needed
	if [ -d "${X_STAGING}/lib/modules/${KVER}" ]; then
		mv  ${X_STAGING}/lib/modules/*.ko  ${X_STAGING}/lib/modules/${KVER}/
		/sbin/depmod -b ${X_STAGING} ${KVER}
		sort ${X_STAGING}/lib/modules/${KVER}/modules.dep \
			modinst/lib/modules/${KVER}/modules.dep \
			| uniq > modinst/lib/modules/${KVER}/modules.dep.merged
		mv -f modinst/lib/modules/${KVER}/modules.dep.merged \
			modinst/lib/modules/${KVER}/modules.dep
	fi

	# Put the factory tools support modules in their own directory
	rm -rf factory_modinst
	mkdir factory_modinst
	for m in $factory_modules
	do
		p=$(find modinst -type f -name $m.ko | sed -e 's|^.*modinst/||')
		[ -z $p ] && continue
		install -D modinst/$p factory_modinst/$p
		rm -f modinst/$p
	done

	# cleanup
	rm -f initramfs.cpio.gz
}

do_clean() {
	rm -Rf modinst
	make distclean || return 1
	rm -f *.ko.sha1
}

