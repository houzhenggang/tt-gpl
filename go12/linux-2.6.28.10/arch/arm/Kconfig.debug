menu "Kernel hacking"

source "lib/Kconfig.debug"

# RMK wants arm kernels compiled with frame pointers or stack unwinding.
# If you know what you are doing and are willing to live without stack
# traces, you can get a slightly smaller kernel by setting this option to
# n, but then RMK will have to kill you ;).
config FRAME_POINTER
	bool
	default y if !ARM_UNWIND && !THUMB2_KERNEL
	help
	  If you say N here, the resulting kernel will be slightly smaller and
	  faster. However, if neither FRAME_POINTER nor ARM_UNWIND are enabled,
	  when a problem occurs with the kernel, the information that is
	  reported is severely limited.

config ARM_UNWIND
	bool "Enable stack unwinding support"
	depends on AEABI && EXPERIMENTAL
	default y
	help
	  This option enables stack unwinding support in the kernel
	  using the information automatically generated by the
	  compiler. The resulting kernel image is slightly bigger but
	  the performance is not affected. Currently, this feature
	  only works with EABI compilers. If unsure say Y.

config DEBUG_USER
	bool "Verbose user fault messages"
	help
	  When a user program crashes due to an exception, the kernel can
	  print a brief message explaining what the problem was. This is
	  sometimes helpful for debugging but serves no purpose on a
	  production system. Most people should say N here.

	  In addition, you need to pass user_debug=N on the kernel command
	  line to enable this feature.  N consists of the sum of:

	      1 - undefined instruction events
	      2 - system calls
	      4 - invalid data aborts
	      8 - SIGSEGV faults
	     16 - SIGBUS faults

config DEBUG_ERRORS
	bool "Verbose kernel error messages"
	depends on DEBUG_KERNEL
	help
	  This option controls verbose debugging information which can be
	  printed when the kernel detects an internal error. This debugging
	  information is useful to kernel hackers when tracking down problems,
	  but mostly meaningless to other people. It's safe to say Y unless
	  you are concerned with the code size or don't want to see these
	  messages.

config DEBUG_STACK_USAGE
	bool "Enable stack utilization instrumentation"
	depends on DEBUG_KERNEL
	help
	  Enables the display of the minimum amount of free stack which each
	  task has ever had available in the sysrq-T output.

config DEBUG_RVIDCC
	bool "Include the RealView ICE DCC channel device driver"
	depends on !DEBUG_ICEDCC
	help
	  Say Y here if you want a serial channel connected through ARM's
	  RealView ICE emulator through to your debugging host.

	  IMPORTANT: if you are not using one of the pre-configured platforms
	  (notably ARM's Integrator or Versatile Platform) then you will need to
	  configure interrupts for DCC and pass the IRQ numbers in the module
	  parameters 'txirq' and 'rxirq', assuming they have been wired into your
	  interrupt controller.

	  If interrupts are not used then a timed polling scheme is used. This
	  introduces poorer performance, using more CPU bandwidth and reducing
	  communication throughput on DCC.

	  This feature requires at least the RealView ICE 1.5 firmware version.

config DEBUG_DCC_KGDB
	bool "Use the RealView ICE DCC serial channel for KGDB debugging"
	depends on DEBUG_RVIDCC && KGDB
	help
	  Say Y here if you want to remotely debug the kernel using gdb and the
	  KGDB kernel debugging patches. Refer to the KGDB documentation for more
	  details.

	  Note that only one device can be enabled as the KGDB communications
	  device, so if this is selected, then KGDB on serial devices or Ethernet
	  must be deselected, or the kernel won't link.

config DEBUG_DCC_RAW
	bool "Disable virtual Ethernet on the RealView ICE DCC channel"
	depends on DEBUG_RVIDCC
	help
	  Say Y here if you want to disable the virtual Ethernet facility
	  of the RealView ICE.

	  The virtual Ethernet facility provides both a serial channel and an
	  Ethernet channel, and can be used for its serial channel even if
	  Ethernet is not required. Using this has the advantage over raw
	  DCC communications in that serial channel writes that do not have
	  an integral multiple of 4 bytes are not stuffed with nulls to make
	  the packet size.

	  DCC communicates in 32-bit words and, in raw mode, data is packed in
	  4 bytes per word. Individual write calls pack the data provided, padding
	  any remainder with nulls. Any protocol using this channel must tolerate
	  the embedded nulls. GDB is such a protocol, provided the driver is fed with
	  complete packets, and not one byte at a time.

# These options are only for real kernel hackers who want to get their hands dirty.
config DEBUG_LL
	bool "Kernel low-level debugging functions"
	depends on DEBUG_KERNEL
	help
	  Say Y here to include definitions of printascii, printch, printhex
	  in the kernel.  This is helpful if you are debugging code that
	  executes before the console is initialized.

config DEBUG_LL_CONSOLE
	bool "Kernel early console"
	depends on DEBUG_LL
	help
	  Say Y here if you want to have an early console using the Kernel
	  low-level debugging functions. Add earlyprintk to your kernel
	  parameters to enable this console.

config DEBUG_ICEDCC
	bool "Kernel low-level debugging via EmbeddedICE DCC channel"
	depends on DEBUG_LL
	help
	  Say Y here if you want the debug print routines to direct their
	  output to the EmbeddedICE macrocell's DCC channel using
	  co-processor 14. This is known to work on the ARM9 style ICE
	  channel.

	  It does include a timeout to ensure that the system does not
	  totally freeze when there is nothing connected to read.

config DEBUG_DC21285_PORT
	bool "Kernel low-level debugging messages via footbridge serial port"
	depends on DEBUG_LL && FOOTBRIDGE
	help
	  Say Y here if you want the debug print routines to direct their
	  output to the serial port in the DC21285 (Footbridge). Saying N
	  will cause the debug messages to appear on the first 16550
	  serial port.

config DEBUG_CLPS711X_UART2
	bool "Kernel low-level debugging messages via UART2"
	depends on DEBUG_LL && ARCH_CLPS711X
	help
	  Say Y here if you want the debug print routines to direct their
	  output to the second serial port on these devices.  Saying N will
	  cause the debug messages to appear on the first serial port.

config DEBUG_S3C_PORT
	depends on DEBUG_LL && PLAT_S3C
	bool "Kernel low-level debugging messages via S3C UART"
	help
	  Say Y here if you want debug print routines to go to one of the
	  S3C internal UARTs. The chosen UART must have been configured
	  before it is used.

config DEBUG_S3C_UART
	depends on PLAT_S3C
	int "S3C UART to use for low-level debug"
	default "0"
	help
	  Choice for UART for kernel low-level using S3C UARTS,
	  should be between zero and two. The port must have been
	  initialised by the boot-loader before use.

	  The uncompressor code port configuration is now handled
	  by CONFIG_S3C_LOWLEVEL_UART_PORT.

config DEBUG_BCM_UART
	depends on PLAT_BCM476X
	int "BCM UART to use for low-level debug"
	default "0"
	help
	  Choice for UART for kernel low-level using BCM UARTS,
	  should be between zero and two. The port must have been
	  initialised by the boot-loader before use.

config DEBUG_ASID
	bool "Exposes ASID to user land"
	depends on CPU_HAS_ASID
	default y
	help
	  This enables ASID to be read in user land

config KMEMCHECK
	bool "kmemcheck: trap use of uninitialized memory"
	depends on SLUB || SLAB
	depends on !CC_OPTIMIZE_FOR_SIZE
	depends on !DEBUG_PAGEALLOC
	select FRAME_POINTER
	select STACKTRACE
	default n
	help
	  This option enables tracing of dynamically allocated kernel memory
	  to see if memory is used before it has been given an initial value.
	  Be aware that this requires half of your memory for bookkeeping and
	  will insert extra code at *every* read and write to tracked memory
	  thus slow down the kernel code (but user code is unaffected).

	  The kernel may be started with kmemcheck=0 or kmemcheck=1 to disable
	  or enable kmemcheck at boot-time. If the kernel is started with
	  kmemcheck=0, the large memory and CPU overhead is not incurred.

choice
	prompt "kmemcheck: default mode at boot"
	depends on KMEMCHECK
	default KMEMCHECK_ONESHOT_BY_DEFAULT
	help
	  This option controls the default behaviour of kmemcheck when the
	  kernel boots and no kmemcheck= parameter is given.

config KMEMCHECK_DISABLED_BY_DEFAULT
	bool "disabled"
	depends on KMEMCHECK

config KMEMCHECK_ENABLED_BY_DEFAULT
	bool "enabled"
	depends on KMEMCHECK

config KMEMCHECK_ONESHOT_BY_DEFAULT
	bool "one-shot"
	depends on KMEMCHECK
	help
	  In one-shot mode, only the first error detected is reported before
	  kmemcheck is disabled.

endchoice

config KMEMCHECK_QUEUE_SIZE
	int "kmemcheck: error queue size"
	depends on KMEMCHECK
	default 64
	help
	  Select the maximum number of errors to store in the queue. This
	  queue will be emptied once every second, so this is effectively a
	  limit on how many reports to print in one go. Note however, that
	  if the number of errors occuring between two bursts is larger than
	  this number, the extra error reports will get lost.

config KMEMCHECK_SHADOW_COPY_SHIFT
	int "kmemcheck: shadow copy size (5 => 32 bytes, 6 => 64 bytes)"
	depends on KMEMCHECK
	range 2 8
	default 6
	help
	  Select the number of shadow bytes to save along with each entry of
	  the queue. These bytes indicate what parts of an allocation are
	  initialized, uninitialized, etc. and will be displayed when an
	  error is detected to help the debugging of a particular problem.

config KMEMCHECK_PARTIAL_OK
	bool "kmemcheck: allow partially uninitialized memory"
	depends on KMEMCHECK
	default y
	help
	  This option works around certain GCC optimizations that produce
	  32-bit reads from 16-bit variables where the upper 16 bits are
	  thrown away afterwards. This may of course also hide some real
	  bugs.

config KMEMCHECK_BITOPS_OK
	bool "kmemcheck: allow bit-field manipulation"
	depends on KMEMCHECK
	default n
	help
	  This option silences warnings that would be generated for bit-field
	  accesses where not all the bits are initialized at the same time.
	  This may also hide some real bugs.

config DEBUG_STACK_USAGE
	bool "Enable stack utilization instrumentation"
	depends on DEBUG_KERNEL
	help
	  Enables the display of the minimum amount of free stack which each
	  task has ever had available in the sysrq-T and sysrq-P debug output.

	  This option will slow down process creation somewhat.

source "kernel/Kconfig.custom-stack"

endmenu
